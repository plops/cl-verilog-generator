(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload "cl-verilog-generator")
  (ql:quickload "alexandria"))

(in-package :cl-verilog-generator)

(progn
  (defparameter *path* "/home/martin/stage/cl-verilog-generator/examples/02_video")
  (defparameter *day-names*
    '("Monday" "Tuesday" "Wednesday"
      "Thursday" "Friday" "Saturday"
      "Sunday"))
  ;; https://github.com/sipeed/TangNano-4K-example/blob/main/dk_video/project/src/ov2640/I2C_Interface.v
  ;; http://www4.cs.umanitoba.ca/~jacky/Teaching/Courses/74.795-LocalVision/ReadingList/ov-sccb.pdf

  (let ((device 'gw1nsr4c-009)
	(fabric-clk 159))
   (loop for e in `((GW_PLLVR
		     (CLKOUTD false)
		     (CLKOUT_FREQ ,fabric-clk)
		     (DYNAMIC true)
		     (CLKOUT_TOLERANCE 0))
		   
		    (TMDS_PLLVR
		     (CLKOUTD true)
		     (CLKOUTD_BYPASS false)
		     (CLKOUTD_FREQ 12.5)
		     (CLKOUTD_SOURCE_CLKOUT true)
		     (CLKOUTD_TOLERANCE 3)
		     (CLKOUT_FREQ 371.25)
		     (DYNAMIC false)
		     (CLKOUT_TOLERANCE 1)
		     ))
	 do
	    (destructuring-bind (ipc-name &rest clauses) e
	      (write-ipc
	       (format nil "~a/source/~a.ipc"  *path* ipc-name)
	       `((General
		  (ipc_version 4)
		  (file ,ipc-name)
		  (module ,ipc-name)
		  (target_device ,device)
		  (type clock_pllvr)
		  (version 1.0))
		 (Config
		  (CKLOUTD3 false)
		  (CLKFB_SOURCE 0)
		  (CLKIN_FREQ 27)
		  ,@clauses
		  (CLKOUTP false)
		  (CLKOUT_BYPASS false)
		  (CLKOUT_DIVIDE_DYN true)
		  (LANG 0)
		  (LOCK_EN true)
		  (MODE_GENERAL true)
		  (PLL_PWD false)
		  (PLL_REGULATOR false)
		  (RESET_PLL false))))))

    (let ((name "hyperram_memory_interface"))
      (write-ipc
       (format nil "~a/source/~a.ipc"  *path* name)
       `((General
	  (ipc_version 4)
	  (file ,name)
	  (module HyperRAM_Memory_Interface_Top)
	  (target_device ,device)
	  (type hyperram_emb)
	  (version 1.0))
	 (Config
	  (BURST_MODE 128)
	  (CLK_TYPE DIFF)
	  (DEEP_POWER_DOWN OFF)
	  (DISABLE_IO true)
	  (DQ_WIDTH 8)
	  (DRIVE_STRENGTH 34)
	  (HYBRID_SLEEP_MODE OFF)
	  (INITIAL_LATENCY 6)
	  (LANG 0)
	  (MEMORY_CLK ,fabric-clk)
	  (MEMORY_TYPE W956x8MKY)
	  (PASR full)
	  (PSRAM_WIDTH 8)
	  (REFRESH_RATE normal)
	  (SIMULATION false)
	  (Synthesis_tool GowinSynthesis)
	  ))))
    (let ((name "dvi_tx"))
      (write-ipc
       (format nil "~a/source/~a.ipc"  *path* name)
       `((General
	  (ipc_version 4)
	  (file ,name)
	  (module DVI_TX_Top)
	  (target_device ,device)
	  (type ,name)
	  (version 1.0))
	 (Config
	  (DISABLE_IO_INSERTION true)
	  (ELVDS false)
	  (LANG 0)
	  (RX_CLOCK_IN_FREQUENCY 40) ;; i guess this from the external clock. is it generated by the tv?
	  (Synthesis_tool GowinSynthesis)
	  (TLVDS true)
	  (USING_EXTERNAL_CLOCK true)))))
    (let ((name "video_frame_buffer"))
      (write-ipc
       (format nil "~a/source/~a.ipc"  *path* name)
       `((General
	  (ipc_version 4)
	  (file ,name)
	  (module Video_Frame_Buffer_Top)
	  (target_device ,device)
	  (type ,name)
	  (version 1.0))
	 (Config
	  (Addr_Width 22)
	  (Data_Width 32)
	  (Disable_IO_Insertion true)
	  (Image_Size 00100000)
	  (LANG 0)
	  (Memory_Type HyperRAM)
	  (Read_Burst_Length 128)
	  (Read_FIFO_Burst_Mult 8)
	  (Read_FIFO_Depth 1024)
	  (Read_Video_Width 16)
	  (Synthesis_tool GowinSynthesis)
	  (User_Three_Frame_Buffer true)
	  (Write_Burst_Length 128)
	  (Write_FIFO_Depth 1024)
	  (Write_Video_Width 16))))))

  
  (write-source
   (format nil "~a/source/i2c_interface.v" *path*)
   `(module i2c_interface
	    ("input clk"		;; 50MHz
	     "input siod"		;; SCCB data signal
	     "output sioc"		;; SCCB clock signal
	     "output taken" ;; flag to go to next address of LUT
	     "input send" ;; flag to indicate if configuration has finished
	     "input [7:0] rega" ;; register address
	     "input [7:0] value" ;; data to write into register address
	     )
	    ,@(loop for e in `((divider 7 "8'b00000001")
			       (busy_sr 31 "{32{1'b0}}")
			       (data_sr 31 "{32{1'b1}}")
			       (sioc_temp)
			       (taken_temp)
			       (siod_temp))
		    collect
		    (destructuring-bind (name &optional size default) e
		      (format nil "reg ~@[[~a:0]~] ~a~@[ =~a~];" size name default)))
	    ,@(loop for e in `(siod sioc taken)
		    collect
		    `(assign ,e ,(format nil "~a_temp" e)))
	    (always-at (or busy_sr (aref data_sr 31))
		       ;; tristate when idle or siod driven by master
		       (if (logior
			    (== (aref busy_sr (slice 11 10))
				"2'b10")
			    (== (aref busy_sr (slice 20 19))
				"2'b10")
			    (== (aref busy_sr (slice 29 28))
				"2'b10"))
			   (setf siod_temp "1'bZ")
			   (setf siod_temp (aref data_sr 31))))
	    (always-at
	     "posedge clk"
	     (setf taken_temp "1'b0")
	     (if (== (aref busy_sr 31)
		     0)
		 (do0
		   (setf sioc_temp 1)
		   (if (== send 1)
		       (if (== divider "8'b0000_0000")
			   (setf data_sr (concat "3'b100"
						 id
						 "1'b0"
						 rega
						 "1'b0"
						 value
						 "1'b0"
						 "2'b01")
				 busy_sr (concat "3'b111"
						 "9'b1_1111_1111"
						 "9'b1_1111_1111"
						 "9'b1_1111_1111"
						 "2'b11")
				 taken_temp "1'b1")
			   (incf divider))
		       )
		   (do0
			(case (concat (aref busy_sr (slice 31 29))
				      (aref busy_sr (slice 2 0)))
			  ,@(loop for e in `(("6'b111_111" 1 1 1 1)
					     ("6'b111_110" 1 1 1 1)
					     ("6'b111_100" 0 0 0 0)
					     ("6'b110_000" 0 1 1 1)
					     ("6'b100_000" 1 1 1 1)
					     ("6'b000_000" 1 1 1 1)
					     (t 0 1 1 0)
					     )
				 
				  collect
				  (destructuring-bind (top-key a b c d) e
				    `(,top-key
				      (case (aref divider (slice 7 6))
					,@(loop for key in `("2'b00" "2'b01" "2'b10" t)
						and f in (list a b c d)
						collect
						`(,key (setf sioc_temp ,f))))))))

			
			(if (== divider "8'b1111_1111")
			    (setf busy_sr (concat (aref busy_sr (slice 30 0))
						  "1'b0")
				  data_sr (concat (aref data_sr (slice 30 0))
						  "1'b1")
				  divider "{8{1'b0}}"
				  )
			    (incf divider))))))))
  (write-source
   (format nil "~a/source/syn_gen.v" *path*)
   `(module syn_gen
	    (,@(loop for e in `((pxl_clk)
				(rst_n)
				(h_total :len 16)
				(h_sync :len 16)
				(h_bporch :len 16)
				(h_res :len 16)
				(v_total :len 16)
				(v_sync :len 16)
				(v_bporch :len 16)
				(v_res :len 16)
				(rd_hres :len 16)
				(rd_vres :len 16)
				(hs_pol ) ;; 0 .. negative polarity
				(vs_pol )
				(rden :type "output reg")
				(de :type "output reg")
				(hs :type "output reg")
				(vs :type "output reg"))
		     collect
		     (destructuring-bind (name &key (type "input") len) e
		       (format nil "~a~@[ [~a:0]~] ~a_~a" type (when len (- len 1))
			       (if (string= type "input")
				   "I"
				   "O")
			       name)))
	     )
	  ,@(loop for e in `((V_cnt 15)
			     (H_cnt 15)
			     (Rden_dn)
			     )
		  collect
		  (destructuring-bind (name &optional size default) e
		    (format nil "reg ~@[[~a:0]~] ~a~@[ =~a~];" size name default)))
	  ,@(loop for e in `(de_w hs_w vs_w de_dn hs_dn vs_dn)
		  collect
		  (format nil "wire Pout_~a" e))
	  ,@(loop for e in `(Rden_w)
		  collect
		  (format nil "wire ~a" e))
	  ,@(loop for e in `(siod sioc taken)
		  collect
		  `(assign ,e ,(format nil "~a_temp" e)))
	  (always-at (or "posedge I_pxl_clk"
			   "negedge I_rst_n")
		       ;; tristate when idle or siod driven by master
		       (if !I_rst_n
			   (setf V_cnt "16'd0")
			   (cond ((logand (<= (- I_v_total "1'b1") V_cnt)
					  (<= (- I_h_total "1'b1") H_cnt))
				  (setf V_cnt "16'd0"))
				 ((<= (- I_h_total "1'b1")
				      H_cnt)
				  (incf V_cnt "1'b1"))
				 (t
				  (setf V_cnt V_cnt))
				 )))
	  (always-at (or "posedge I_pxl_clk"
			 "negedge I_rst_n") 
		     (cond (!I_rst_n
			    (setf H_cnt "16'd0"))
			   ((<= (- I_h_total "1'b1")
				H_cnt)
			    (setf H_cnt "16'd0"))
			   (t
			    (incf H_cnt "1'b1")))
		     )
	  (assign Pout_de_w (and ,@(loop for dir in `(H V)
			   collect
			   (let* ((sdir (string-downcase dir))
				  (cnt (format nil "~a_cnt" dir))
				  (sync (format nil "I_~a_sync" sdir))
				  (bporch (format nil "I_~a_bporch" sdir))
				  (res (format nil "I_~a_res" sdir)))
			     `(and (<= (+ ,sync ,bporch)
				     ,cnt)
				 (<= ,cnt
				     (- (+ ,sync
					 ,bporch
					 ,res
					 )
					"1'b1"))))))
		  #+nil (and (and (<= (+ I_h_sync I_h_bporch)
					  H_cnt)
				      (<= H_cnt
					  (- (+ I_h_sync I_h_bporch I_h_res )
					     "1'b1")))
				 (and (<= (+ I_v_sync I_v_bporch)
					  V_cnt)
				      (<= V_cnt
					  (- (+ I_v_sync I_v_bporch I_v_res )
					     "1'b1")))))
	  (assign Pout_hs_w (~ (and (<= "16'd0"
					H_cnt)
				    (<= H_cnt (- I_h_sync "1'b1"))))
		  )
	  (assign Pout_vs_w (~ (and (<= "16'd0"
					V_cnt)
				    (<= V_cnt (- I_v_sync "1'b1"))))
		  )
	  (assign Rden_w
		  (and ,@(loop for dir in `(H V)
			   collect
			   (let* ((sdir (string-downcase dir))
				  (cnt (format nil "~a_cnt" dir))
				  (sync (format nil "I_~a_sync" sdir))
				  (bporch (format nil "I_~a_bporch" sdir))
				  (res (format nil "I_rd_~ares" sdir)))
			     `(and (<= (+ ,sync ,bporch)
				     ,cnt)
				 (<= ,cnt
				     (- (+ ,sync
					 ,bporch
					 ,res
					 )
					"1'b1")))))))
	  (always-at (or "posedge I_pxl_clock"
			 "negedge I_rst_n")
		     (if I_rst_n
			 (setf ,@(loop for e in `(Pout_de Pout_hs Pout_vs Rden)
				       appending
				       `(,(format nil "~a_dn" e)
					 ,(format nil "~a_w" e))))
			 (setf ,@(loop for (e f) in `((Pout_de 0) ( Pout_hs 1) (Pout_vs 1) (Rden 0))
				       appending
				       `(,(format nil "~a_dn" e)
					 ,(format nil "1'b~a" f))))
			 ))
	  (always-at (or "posedge I_pxl_clock"
			 "negedge I_rst_n")
		     (if I_rst_n
			 (setf O_de Pout_de_dn
			       O_hs (? I_hs_pol (~ Pout_hs_dn) Pout_hs_dn)
			       O_hs (? I_vs_pol (~ Pout_vs_dn) Pout_vs_dn)
			       O_rden Rden_dn)
			 (setf ,@(loop for (e f) in `((O_de 0)
						      (O_hs 1)
						      (O_vs 1)
						      (O_rden 0))
				       appending
				       `(,(format nil "~a_dn" e)
					 ,(format nil "1'b~a" f))))
			 ))
	    ))

  ;; https://www.uctronics.com/download/cam_module/OV2640DS.pdf v.1.6
  ;; http://www.uctronics.com/download/OV2640_DS.pdf v.2.2
  (write-source
   (format nil "~a/source/ov2640_registers.v" *path*)
   `(module ov2640_interface
	    ("input clk"		
	     "input resend"
	     "input advance"
	     "output [15:0] command" 
	     "output finished")
	    ,@(loop for e in `((sreg 15)
			       (finished_temp)
			       (address 8 "{9{1'b0}}")
			       )
		    collect
		    (destructuring-bind (name &optional size default) e
		      (format nil "reg ~@[[~a:0]~] ~a~@[ =~a~];" size name default)))
	    (assign command sreg
		    finished finished_temp)
	    (always-at sreg
		       ;; when register and value is FFFF indicate config is finished
		       (if (== sreg "16'hFFFF")
			   (setf finished_temp 1)
			   (setf finished_temp 0)))
	    (always-at
	     "posedge clk"
	     (cond ((== resend 1)
		    (setf address "{8{1'b0}}"))
		   ((== advance 1)
		    (incf address)))
	     
	     ,(let ((l  `((FF 01) (12 80)
			  (FF 00) (2c ff) (2e df)
			  (FF 01) (3c 32) (11 80) ;/* Set PCLK divider */
			  (09 02)	;/* Output drive x2 */
			  (04 28) (13 E5) (14 48) (15 00) ;//Invert VSYNC
			  (2c 0c) (33 78) (3a 33) (3b fb) (3e 00) (43 11) (16 10) (39 02) (35 88) (22 0a) (37 40) (23 00)
			  (34 a0) (06 02) (06 88) (07 c0) (0d b7) (0e 01) (4c 00) (4a 81) (21 99) (24 40) (25 38) (26 82) ;/* AGC/AEC fast mode operating region */	
			  (48 00)	;/* Zoom control 2 MSBs */
			  (49 00)	;/* Zoom control 8 MSBs */
			  (5c 00) (63 00) (46 00) (47 00) (0C 3A) ;/* Set banding filter */
			  (5D 55) (5E 7d) (5F 7d) (60 55) (61 70) (62 80) (7c 05) (20 80) (28 30) (6c 00) (6d 80) (6e 00)
			  (70 02) (71 94) (73 c1) (3d 34) (5a 57) (4F bb) (50 9c)
			  (FF 00) (e5 7f) (F9 C0) (41 24) (E0 14) (76 ff) (33 a0) (42 20) (43 18) (4c 00) (87 D0) (88 3f) (d7 03) (d9 10) (D3 82) (c8 08) (c9 80)
			  (7C 00) (7D 00) (7C 03) (7D 48) (7D 48) (7C 08) (7D 20) (7D 10) (7D 0e)
			  (90 00) (91 0e) (91 1a) (91 31) (91 5a) (91 69) (91 75) (91 7e) (91 88) (91 8f) (91 96) (91 a3) (91 af) (91 c4) (91 d7) (91 e8) (91 20)
			  (92 00) (93 06) (93 e3) (93 03) (93 03) (93 00) (93 02) (93 00) (93 00) (93 00) (93 00) (93 00) (93 00) (93 00) (96 00)
			  (97 08) (97 19) (97 02) (97 0c) (97 24) (97 30) (97 28) (97 26) (97 02) (97 98) (97 80) (97 00) (97 00)
			  (a4 00) (a8 00) (c5 11) (c6 51) (bf 80) (c7 10) (b6 66) (b8 A5) (b7 64) (b9 7C) (b3 af) (b4 97) (b5 FF) (b0 C5) (b1 94) (b2 0f) (c4 5c) (a6 00)
			  (a7 20) (a7 d8) (a7 1b) (a7 31) (a7 00) (a7 18) (a7 20) (a7 d8) (a7 19) (a7 31) (a7 00) (a7 18) (a7 20) (a7 d8) (a7 19) (a7 31) (a7 00) (a7 18)
			  (7f 00) (e5 1f) (e1 77) (dd 7f) (C2 0E)
			  (FF 01) (FF 00) (E0 04) (DA 04) ;//08:RGB565  04:RAW10
			  (D7 03) (E1 77) (E0 00)
			  (FF 00) (05 01) (5A A0) ;//(w>>2)&0xFF	//28:w=160 //A0:w=640 //C8:w=800
			  (5B 78) ;//(h>>2)&0xFF	//1E:h=120 //78:h=480 //96:h=600
			  (5C 00) ;//((h>>8)&0x04)|((w>>10)&0x03)		
			  (FF 01) (11 80) ;//clkrc=0x83 for resolution <= SVGA		
			  (FF 01) (12 40) ;/* DSP input image resoultion and window size control */
			  (03 0A) ;/* UXGA=0x0F, SVGA=0x0A, CIF=0x06 */
			  (32 09) ;/* UXGA=0x36, SVGA/CIF=0x09 */
			  (17 11) ;/* UXGA=0x11, SVGA/CIF=0x11 */
			  (18 43) ;/* UXGA=0x75, SVGA/CIF=0x43 */
			  (19 00) ;/* UXGA=0x01, SVGA/CIF=0x00 */
			  (1A 4b) ;/* UXGA=0x97, SVGA/CIF=0x4b */
			  (3d 38) ;/* UXGA=0x34, SVGA/CIF=0x38 */
			  (35 da) (22 1a) (37 c3) (34 c0) (06 88) (0d 87) (0e 41) (42 03) (FF 00) ;/* Set DSP input image size and offset. The sensor output image can be scaled with OUTW/OUTH */
			  (05 01) (E0 04) (C0 64) ;/* Image Horizontal Size 0x51[10:3] */  //11 0010 0000 = 800
			  (C1 4B) ;/* Image Vertiacl Size 0x52[10:3] */    //10 0101 1000 = 600   
			  (8C 00) ;/* {0x51[11], 0x51[2:0], 0x52[2:0]} */
			  (53 00) ;/* OFFSET X[7:0] */
			  (54 00) ;/* OFFSET Y[7:0] */
			  (51 C8) ;/* H SIZE[7:0]= 0x51/4 */ //200
			  (52 96) ;/* V SIZE[7:0]= 0x52/4 */ //150       
			  (55 00) ;/* V SIZE[8]/OFFSET Y[10:8]/H SIZE[8]/OFFSET X[10:8] */
			  (57 00) ;/* H SIZE[9] */
			  (86 3D) (50 80) ;/* H DIVIDER/V DIVIDER */        
			  (D3 80)	   ;/* DVP prescalar */
			  (05 00) (E0 00) (FF 00) (05 00)
			  (FF 00) (E0 04) (DA 04) ;//08:RGB565  04:RAW10
			  (D7 03) (E1 77) (E0 00)    
			  )
			))
		`(case address
		   ,@(loop for (e f) in l
			   and i from 0
			   collect
			   `(,(format nil "~3,'0d" i)
			     (setf sreg ,(format nil "16'h~a_~a" e f))))
		   (t (setf sreg "16'hFF_FF"))
		   )))))
  (write-source
   (format nil "~a/source/ov2640_controller.v" *path*)
   `(module ov2640_controller
	    ("input clk"		
	     "input resend"
	     "output config_finished"
	     "output sioc"
	     "inout siod"
	     "output reset"
	     "output pwdn")
	    ,@(loop for e in `((command 15)
			       (finished)
			       (taken)
			       )
		    collect
		    (destructuring-bind (name &optional size default) e
		      (format nil "wire ~@[[~a:0]~] ~a~@[ =~a~];" size name default)))
	    ,@(loop for e in `((send :default 0)
			       
			       )
		    collect
		    (destructuring-bind (name &key size default) e
		      (format nil "reg ~@[[~a:0]~] ~a~@[ =~a~];" size name default)))
	    (assign config_finished finished
		    reset 1
		    pwdn 0)
	    (always-at finished
		       (assign= send ~finished))
	    (make-instance ov2640_registers
			   (lut :clk clk
				:advance taken
				:command command
				:finished finished
				:resend resend))
	    (make-instance i2c_interface
			   (i2c
			    :clk clk
			    :taken taken
			    :siod siod
			    :sioc sioc
			    :send send
			    :rega (aref command (slice 15 8))
			    :value (aref command (slice 7 0)))
			   )
	    )))
